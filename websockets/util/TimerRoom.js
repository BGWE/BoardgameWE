const moment = require('moment');
const db = require('../../api/models/index');
const access = require("../../api/util/access_checks");
const TimerController = require('../../api/TimerController');
const util = require("./util");

/**
 *  A class representing a timer room
 *
 *  NOTE: all datetimes should be generated by the socket server to remain consistent
 */
class TimerRoom {
    constructor(socket, id_timer) {
        this.socket = socket;
        this.id_timer = id_timer;
        this.timer = null;
        this.reload = null;  // not null if timer is of type REALOD
        this.errors = {
            TIMER_ALREADY_STARTED: "timer already started",
            TIMER_HAS_RAN_OUT: "timer has ran out of time",
            TIMER_ALREADY_STOPPED: "timer already stopped"
        }
    }

    /** Fetches current timer data and set class attributes accordingly */
    async setTimer(options) {
        this.timer = await db.GameTimer.findByPk(this.id_timer, {...options, rejectOnEmpty: true});
        if (this.timer.timer_type === db.GameTimer.RELOAD) {
            this.reload = await db.ReloadGameTimer.findByPk(this.id_timer, options);
        }
    }

    // timer must have been set before calling this function
    async can_access_timer(access_type) {
        try {
            if (this.timer.id_event) {
                return await access.can_access_event(access_type, () => this.timer.id_event, () => util.getCurrentUser(this.socket).id);
            } else {
                return await access.can_access_timer(access_type, () => this.id_timer, () => util.getCurrentUser(this.socket).id)
            }
        } catch (e) {
            if (e instanceof access.NotFoundError) {
                return false;
            } else {
                throw  e;
            }
        }
    }

    static buildRoomName(id_timer) {
        return "timer/" + id_timer;
    }

    getRoomName() {
        return TimerRoom.buildRoomName(this.id_timer);
    }

    join() {
        this.socket.join(this.getRoomName());
    }

    leave() {
        this.socket.leave(this.getRoomName());
    }

    emit(context, action, data) {
        context.to(this.getRoomName()).emit(action, data);
    }

    /**
     * Broadcast the action to the timer room, and sends the current state of the timer as message (fetches is from the database
     * @param action str
     * @returns {Promise<void>}
     */
    async emitWithState(context, action) {
        const timer = await db.GameTimer.findOne({
            where: {id: this.id_timer},
            include: TimerController.getFullTimerIncludes()
        });
        this.emit(context, action, timer);
        return timer;
    }

    async timerCanBeAccessed(access_type) {

    }

    async getTimer(options) {
        return await db.GameTimer.findOne(Object.assign({
            where: {id: this.id_timer}
        }, options));
    }

    async getPlayerCount(options) {
        return await db.PlayerGameTimer.count({ where: { id_timer: this.id_timer } }, options);
    }

    async getPlayerById(player_id, options) {
        return await db.PlayerGameTimer.findByPk(player_id, options);
    }

    async getPlayerPerTurn(player_turn, options) {
        return await db.PlayerGameTimer.findOne({ where: { id_timer: this.id_timer, turn_order: player_turn }}, options);
    }

    async getPlayers() {
        return await db.PlayerGameTimer.findAll({
            attributes: ['id', 'id_timer', 'id_user', 'turn_order'],
            where: {id_timer: this.id_timer}
        });
    }

    /**
     * Start the given player timer (based on player turn). If the timer is already started nothing is changed.
     * @param player_turn int|null Null for starting current player timer, a turn order for starting the timer of the player at this turn order
     * @param transaction Transaction Transaction the start operation is executed in (mandatory)
     * @returns {Promise<*>} {success: true|false, [error: str]}  (true if timer started, error message only if
     * success is false)
     */
    async startTimer(player_turn, transaction) {
        await this.setTimer({ transaction, lock: transaction.LOCK.SHARE });
        player_turn = player_turn != null ? player_turn : this.timer.current_player;
        const player = await this.getPlayerPerTurn(player_turn, { transaction, lock: transaction.LOCK.UPDATE });
        if (player.start !== null) {
            return {success: false, error: this.errors.TIMER_ALREADY_STARTED};
        } else if (this.timer.timer_type !== db.GameTimer.COUNT_UP && this.timer.initial_duration - player.elapsed <= 0) {
            return {success: false, error: this.errors.TIMER_HAS_RAN_OUT};
        }
        await player.update({start: moment().utc() }, {transaction});
        return {success: true, error:""};
    }

    /**
     * Stop the current player timer (based on player turn). If the timer is already stopped nothing is changed.
     * @param transaction Transaction Transaction the stop operation is executed in (mandatory)
     * @returns {Promise<*>} {success: true|false, [error: str]}  (true if timer stopped, error message only if
     * success is false)
     */
    async stopTimer(transaction) {
        await this.setTimer({ transaction, lock: transaction.LOCK.SHARE });
        const player = await this.getPlayerPerTurn(this.timer.current_player, { transaction, lock: transaction.LOCK.UPDATE });
        if (player.start == null) {
            return {success: false, error: this.errors.TIMER_ALREADY_STOPPED};
        }
        let data = { elapsed: player.elapsed + moment().diff(player.start), start: null };
        if (this.timer.timer_type === db.GameTimer.RELOAD) { // subtract duration increment
            data.elapsed = Math.max(0, data.elapsed - this.reload.duration_increment);
        }
        await player.update(data, {transaction});
        return {success: true}
    }

    /**
     * Change the current player
     * @param new_player int
     * @param transaction Transaction
     * @returns {Promise<void>}
     */
    async updateCurrentPlayer(new_player, transaction) {
        return await db.GameTimer.update({ current_player: new_player }, { where: {id: this.id_timer}, transaction });
    }

    /**
     * Change current player
     * @param take_next True for taking next, false for taking previous
     * @returns {Promise<*>}
     */
    async changePlayer(take_next) {
        let self = this;
        return db.sequelize.transaction(async function(transaction) {
            await self.setTimer({ transaction, lock: transaction.LOCK.UPDATE });
            const count = await self.getPlayerCount({transaction});
            const stop_action = await self.stopTimer(transaction);
            const next_player = (self.timer.current_player + (take_next ? 1 : count - 1)) % count;
            let results = [await self.updateCurrentPlayer(next_player, transaction)];
            if (stop_action.success) {
                results.push(await self.startTimer(next_player, transaction));
            }
            return results;
        });
    }

    async nextPlayer() {
        return this.changePlayer(true);
    }

    async prevPlayer() {
        return this.changePlayer(false);
    }

    async changePlayerTurnOrder(player_id, turn_order, transaction) {
        return db.PlayerGameTimer.update({
            turn_order: turn_order,
            start: null
        }, {
            transaction,
            where: { id_timer: this.id_timer, id: player_id }
        });
    }

}

exports.TimerRoom = TimerRoom;